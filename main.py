def  heapify ( числа : список , размер кучи : int , корень : int ):
    самый большой  =  корень   # инициализируем наибольший элемент, как корень
    left  =  2  *  root  +  1   # левый элемент = 2*i + 1
    правый  =  2  *  корень  +  2   # правый 2*i + 2

    # Если левый дочерний элемент больше

    если  осталось  <  размер_кучи  и  числа [ слева ] >  числа [ самые большие ]:
        самый большой  =  левый

    # Если правый дочерний элемент больше самого большого на данный момент
    если  право  <  размер_кучи  и  числа [ право ] >  числа [ самые большие ]:
        самый большой  =  правый

        # Если самый элемент большой не корень
    если  самый большой  !=  корень :
        числа [ корень ], числа [ самые большие ] =  числа [ самые большие ], числа [ корень ]
        # Рекурсивно преобразуем в двоичную массу рассеянное поддерево
        heapify ( числа , размер кучи , наибольший )


def  heap_sort ( числа : список ) ->  список :
    для  i  в  диапазоне ( len ( числа ) //  2  -  1 , - 1 , - 1 ):   # построение кучи (перегруппировка массива)
        heapify ( числа , len ( числа ), i )

    # Извлекаем элементы из кучи
    для  i  в  диапазоне ( len ( числа ) -  1 , 0 , - 1 ):
        числа [ 0 ], числа [ i ] =  числа [ i ], числа [ 0 ]   # Перемещаем занимаемся корень в конец
        # вызывать объекты heapify на уменьшенной куче
        нагромождать ( числа , я , 0 )
    возвращаемые  числа